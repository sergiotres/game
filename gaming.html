<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Movimiento y Animación con WASD - Personaje de Espaldas</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 4px;
      font-family: sans-serif;
      z-index: 100;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <p>Usa WASD para mover el personaje</p>
  </div>
  <div id="container"></div>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/FBXLoader.js';

    // Elementos básicos
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xaaaaaa);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Usamos los valores fijos que definiste
    camera.position.set(-0.44, 21.03, 28.95);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Controles de cámara
    const controls = new OrbitControls(camera, renderer.domElement);
    // Se asume que el target ya lo definiste previamente
    controls.target.set(0, 1, 0);
    controls.update();

    // Luces
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 50, 0);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);

    // Suelo
    const planeGeometry = new THREE.PlaneGeometry(200, 200);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Variables para el modelo y animaciones
    let mixer = null;
    let idleAction = null;
    let runAction = null;
    let model = null;
    const clock = new THREE.Clock();
    
    // Variables de movimiento
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    const speed = 0.1;

    // Función para configurar sombras
    function setupModel(object) {
      object.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      scene.add(object);
    }

    const fbxLoader = new FBXLoader();
    // Cargar el modelo Idle
    fbxLoader.load(
      './GreatSwordIdle.fbx',
      (object) => {
        model = object;
        setupModel(model);
        // Fijar la escala (por ejemplo, 0.1)
        model.scale.set(0.1, 0.1, 0.1);
        // ROTAR 180° en Y para que se muestre de espaldas
        model.rotation.y = Math.PI;
        if (object.animations && object.animations.length) {
          mixer = new THREE.AnimationMixer(object);
          // Suponemos que el primer clip es idle
          idleAction = mixer.clipAction(object.animations[0]);
          idleAction.play();
          // Si tienes una animación de correr, podrías asignarla a runAction
          // runAction = mixer.clipAction(object.animations[1]); // Ejemplo
        }
      },
      (xhr) => { console.log(`Idle: ${(xhr.loaded / xhr.total * 100).toFixed(0)}% cargado`); },
      (error) => { console.error('Error al cargar GreatSwordIdle.fbx', error); }
    );

    // Manejo de entradas de teclado
    window.addEventListener('keydown', (e) => {
      switch(e.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
      }
      // Si se presiona una tecla de movimiento, activar animación de correr si está disponible
      if ((moveForward || moveBackward || moveLeft || moveRight) && runAction && !runAction.isRunning()) {
        idleAction.crossFadeTo(runAction, 0.2, false);
        runAction.play();
      }
    });

    window.addEventListener('keyup', (e) => {
      switch(e.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
      // Si se sueltan las teclas de movimiento, volver a idle si se tiene runAction
      if (!moveForward && !moveBackward && !moveLeft && !moveRight && runAction) {
        runAction.crossFadeTo(idleAction, 0.2, false);
        idleAction.reset();
        idleAction.play();
      }
    });

    // Actualizar la posición del modelo
    function updateMovement() {
      if (!model) return;
      const moveDir = new THREE.Vector3();
      if (moveForward) moveDir.z -= 1;
      if (moveBackward) moveDir.z += 1;
      if (moveLeft) moveDir.x -= 1;
      if (moveRight) moveDir.x += 1;
      moveDir.normalize();
      model.position.add(moveDir.multiplyScalar(speed));
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      updateMovement();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
